---
title: Core Client APIs
description: Complete API reference for the Erebus PubSub client
---

# Core Client APIs

The Erebus PubSub client provides real-time messaging, presence tracking, and message history APIs.

## Quickstart

```ts
import { ErebusClient, ErebusClientState } from "@erebus-sh/sdk/client";
import { createGenericAdapter } from "@erebus-sh/sdk/server";
import { Access, ErebusService } from "@erebus-sh/sdk/service";

const client = ErebusClient.createClient({
  client: ErebusClientState.PubSub,
  authBaseUrl: "http://localhost:4919",
  wsBaseUrl: "ws://localhost:8787", // optional for self-hosted
});

const SECRET_API_KEY = process.env.SECRET_API_KEY!;

const app = createGenericAdapter({
  authorize: async (channel) => {
    const userId = Math.random().toString(36).substring(2, 15);
    const service = new ErebusService({
      secret_api_key: SECRET_API_KEY,
      base_url: "http://localhost:3000",
    });

    const session = await service.prepareSession({ userId });
    session.join(channel);
    session.allow("*", Access.ReadWrite);
    return session;
  },
});

Bun.serve({ port: 4919, fetch: app.fetch });

async function main() {
  const topic = "chat:lobby";
  
  client.joinChannel("chats");
  await client.connect();

  // Subscribe to messages
  await client.subscribe(topic, (msg) => {
    console.log("ðŸ“©", msg.payload, "from", msg.senderId);
  });

  // Track presence
  await client.onPresence(topic, (presence) => {
    console.log("ðŸ‘¤", presence.status, presence.clientId);
  });

  // Publish with acknowledgement
  await client.publishWithAck(
    topic,
    "Hello Erebus ðŸ‘‹",
    (ack) => console.log("âœ… Ack:", ack),
    3000
  );
  
  // Fetch message history
  const history = await client.getHistory(topic, {
    limit: 50,
    direction: "backward"
  });
  console.log("ðŸ“œ History:", history.items.length, "messages");
}

main().catch(console.error);
```

Check the full example: [Chat TypeScript](https://github.com/erebus-sh/erebus/tree/master/examples/chat-ts)

---

## API Reference

### Client Creation

#### `ErebusClient.createClient(options)`

Creates and configures a PubSub client instance.

**Parameters:**
- `client: ErebusClientState.PubSub` - Client type selector
- `authBaseUrl: string` - URL of your authentication server
- `wsBaseUrl?: string` - WebSocket URL (defaults to `wss://gateway.erebus.sh`)

**Returns:** `ErebusPubSubClient`

```ts
const client = ErebusClient.createClient({
  client: ErebusClientState.PubSub,
  authBaseUrl: "https://your-auth-server.com",
  wsBaseUrl: "wss://gateway.erebus.sh", // optional
});
```

---

### Connection Management

#### `joinChannel(channel: string): void`

Sets the channel for this client instance. Must be called before `connect()`.

```ts
client.joinChannel("chat-room");
```

#### `connect(timeout?: number): Promise<void>`

Establishes WebSocket connection. Automatically fetches grant tokens from `authBaseUrl`.

**Parameters:**
- `timeout?: number` - Connection timeout in milliseconds (default: 30000)

```ts
await client.connect();
// or with custom timeout
await client.connect(10000);
```

#### `close(): void`

Closes the WebSocket connection and cleans up resources.

```ts
client.close();
```

---

### Real-Time Messaging

#### `subscribe(topic, handler, options?): Promise<void>`

Subscribe to messages on a topic.

**Parameters:**
- `topic: string` - Topic name to subscribe to
- `handler: (message: MessageBody) => void` - Message callback
- `options?: SubscribeOptions` - Optional configuration

**Message Format:**
```ts
interface MessageBody {
  id: string;           // Unique message ID
  topic: string;        // Topic name
  senderId: string;     // Sender's client ID
  seq: string;          // Sequence number (ULID)
  sentAt: Date;         // Server timestamp
  payload: string;      // Message content
  clientMsgId?: string; // Optional client correlation ID
}
```

**Example:**
```ts
await client.subscribe("chat:lobby", (msg) => {
  console.log(`${msg.senderId}: ${msg.payload}`);
});

// With options
await client.subscribe(
  "chat:lobby", 
  (msg) => console.log(msg),
  { deliverMissedMessages: true }
);
```

#### `unsubscribe(topic: string): void`

Unsubscribe from a topic.

```ts
client.unsubscribe("chat:lobby");
```

#### `publish(topic, payload): Promise<string>`

Publish a message without acknowledgement.

**Parameters:**
- `topic: string` - Topic to publish to
- `payload: string` - Message content

**Returns:** `Promise<string>` - Client message ID

```ts
const msgId = await client.publish("chat:lobby", "Hello!");
```

#### `publishWithAck(topic, payload, onAck, timeout?): Promise<string>`

Publish with server acknowledgement.

**Parameters:**
- `topic: string` - Topic to publish to
- `payload: string` - Message content  
- `onAck: (ack: AckPacket) => void` - Acknowledgement callback
- `timeout?: number` - Timeout in milliseconds (default: 3000)

```ts
await client.publishWithAck(
  "chat:lobby",
  "Hello!",
  (ack) => {
    if (ack.ack === "ok") {
      console.log("Message delivered!");
    }
  },
  5000
);
```

---

### Message History

#### `getHistory(topic, options?): Promise<HistoryResponse>`

Fetch historical messages with cursor-based pagination.

**Parameters:**
- `topic: string` - Topic to fetch history for
- `options?: HistoryOptions`
  - `cursor?: string` - ULID cursor for pagination
  - `limit?: number` - Messages per page (1-1000, default: 50)
  - `direction?: "forward" | "backward"` - Sort order (default: "backward")

**Returns:**
```ts
interface HistoryResponse {
  items: MessageBody[];      // Array of messages
  nextCursor: string | null; // Cursor for next page
}
```

**Examples:**

```ts
// Get latest 50 messages (newest first)
const history = await client.getHistory("chat:lobby");
console.log(history.items); // Array of 50 messages
console.log(history.nextCursor); // Use for next page

// Paginate through history
let cursor: string | null = null;
do {
  const page = await client.getHistory("chat:lobby", {
    cursor: cursor || undefined,
    limit: 100,
    direction: "backward"
  });
  
  console.log(`Fetched ${page.items.length} messages`);
  cursor = page.nextCursor;
} while (cursor);

// Get oldest messages first
const oldMessages = await client.getHistory("chat:lobby", {
  direction: "forward",
  limit: 20
});
```

#### `createHistoryIterator(topic, options?): () => Promise<IteratorResult | null>`

Create a paginator function for convenient history iteration.

**Parameters:**
- `topic: string` - Topic to fetch history for
- `options?: { limit?: number; direction?: "forward" | "backward" }`

**Returns:** Iterator function that returns `{ items: MessageBody[]; hasMore: boolean } | null`

**Example:**
```ts
const getNext = client.createHistoryIterator("chat:lobby", {
  limit: 50,
  direction: "backward"
});

// Fetch first batch
const first = await getNext();
if (first) {
  console.log(`Got ${first.items.length} messages`);
  console.log(`Has more: ${first.hasMore}`);
}

// Fetch second batch
const second = await getNext();
if (second) {
  console.log(`Got ${second.items.length} more`);
}

// When exhausted, returns null
const done = await getNext(); // null
```

---

### Presence Tracking

#### `onPresence(topic, handler): Promise<void>`

Register a presence handler for online/offline events.

**Parameters:**
- `topic: string` - Topic to track presence on
- `handler: (presence: PresencePacket) => void` - Presence callback

**Presence Format:**
```ts
interface PresencePacket {
  clientId: string;           // Client that changed status
  topic: string;              // Topic name
  status: "online" | "offline"; // Presence status
}
```

**Example:**
```ts
await client.onPresence("chat:lobby", (presence) => {
  console.log(`${presence.clientId} is ${presence.status}`);
});
```

#### `offPresence(topic, handler): void`

Remove a specific presence handler.

```ts
const handler = (p) => console.log(p);
await client.onPresence("chat:lobby", handler);

// Later...
client.offPresence("chat:lobby", handler);
```

#### `clearPresenceHandlers(topic): void`

Remove all presence handlers for a topic.

```ts
client.clearPresenceHandlers("chat:lobby");
```

---

### Connection State

#### `isConnected: boolean`

Check if WebSocket is connected.

```ts
if (client.isConnected) {
  console.log("Ready to send messages");
}
```

#### `isReadable: boolean`

Check if client can receive messages.

```ts
if (client.isReadable) {
  console.log("Receiving messages");
}
```

#### `isWritable: boolean`

Check if client can send messages.

```ts
if (client.isWritable) {
  await client.publish("topic", "message");
}
```

---

## Types Reference

### `ErebusClientState`

```ts
enum ErebusClientState {
  PubSub = 0  // Select PubSub client
}
```

### `SubscribeOptions`

```ts
interface SubscribeOptions {
  deliverMissedMessages?: boolean; // Catch up on missed messages
}
```

### `Access`

```ts
enum Access {
  ReadWrite = "rw",  // Full read/write access
  Read = "r",        // Read-only access
  Write = "w"        // Write-only access
}
```

---

## Error Handling

All async methods can throw errors. Always use try-catch:

```ts
try {
  await client.connect();
  await client.subscribe("topic", handler);
} catch (error) {
  console.error("Failed to connect:", error);
}
```

Common errors:
- `"Channel must be set before connecting"` - Call `joinChannel()` first
- `"HTTP base URL required for history API"` - History requires `httpBaseUrl` option
- `"Connection timeout"` - Server unreachable or slow network

---

## Best Practices

### 1. Always set channel before connecting

```ts
client.joinChannel("my-channel");
await client.connect();
```

### 2. Handle reconnection

```ts
async function connectWithRetry(maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      await client.connect();
      return;
    } catch (error) {
      console.log(`Retry ${i + 1}/${maxRetries}`);
      await new Promise(r => setTimeout(r, 1000 * (i + 1)));
    }
  }
  throw new Error("Failed to connect after retries");
}
```

### 3. Clean up on exit

```ts
process.on("SIGINT", () => {
  client.close();
  process.exit(0);
});
```

### 4. Use history for catch-up

```ts
// Get messages since last seen
const lastSeq = localStorage.getItem("lastSeq");
const history = await client.getHistory("topic", {
  cursor: lastSeq || undefined,
  direction: "forward"
});

// Process historical messages
history.items.forEach(msg => processMessage(msg));

// Save latest sequence
if (history.items.length > 0) {
  const latestSeq = history.items[history.items.length - 1].seq;
  localStorage.setItem("lastSeq", latestSeq);
}

// Now subscribe for real-time
await client.subscribe("topic", processMessage);
```

---

## Examples

Find complete working examples:

- [Basic Chat (TypeScript)](https://github.com/erebus-sh/erebus/tree/master/examples/chat-ts)
- [Typed Client](https://github.com/erebus-sh/erebus/tree/master/examples/chat-ts-typed)
- [TUI Chat](https://github.com/erebus-sh/erebus/tree/master/examples/chat-tui)
- [Next.js Chat App](https://github.com/erebus-sh/erebus/tree/master/examples/chat-app)